#[derive(Debug)]
pub enum OpCode {
    Nop,
    IconstM1,
    Iconst0,
    Iconst1,
    Iconst2,
    Iconst3,
    Iconst4,
    Iconst5,
    Lconst0,
    Lconst1,
    Bipush { byte: i8 },
    Sipush { value: i16 },
    Ldc { index: u8 },
    Ldc2w { index: u16 }, 
    Iload { index: u8 },
    Lload { index: u8 },
    Iload0,
    Iload1,
    Iload2,
    Iload3,
    Lload0,
    Lload1,
    Lload2,
    Lload3,
    Aload0,
    Aload1,
    Aload2,
    Aload3,
    Iaload,
    Caload,
    Istore { index: u8 },
    Lstore { index: u8 },
    Istore0,
    Istore1,
    Istore2,
    Istore3,
    Lstore0,
    Lstore1,
    Lstore2,
    Lstore3,
    Astore0,
    Astore1,
    Astore2,
    Astore3,
    Iastore,
    Castore,
    Pop,
    Dup,
    Iadd,
    Isub,
    Lsub,
    Imul,
    Lmul,
    Idiv,
    Ladd,
    Ldiv,
    Irem,
    Ineg,
    Ishl,
    Lshl,
    Iushr,
    Iand,
    Ior,
    I2l,
    L2i,
    I2b,
    I2c,
    Lcmp,
    Iinc { index: u8, immediate: i8 },
    IfEq { offset: i16 },
    IfNe { offset: i16 },
    IfLt { offset: i16 },
    IfGe { offset: i16 },
    IfGt { offset: i16 },
    IfLe { offset: i16 },
    IfICmpEq { offset: i16 },
    IfICmpNe { offset: i16 },
    IfICmpLt { offset: i16 },
    IfICmpGe { offset: i16 },
    IfICmpGt { offset: i16 },
    IfICmpLe { offset: i16 },
    Goto { offset: i16 },
    Ireturn,
    Areturn,
    Return,
    GetStatic { index: u16 },
    PutStatic { index: u16 },
    GetField { index: u16 },
    PutField { index: u16 },
    InvokeVirtual { index: u16 },
    InvokeSpecial { index: u16 },
    InvokeStatic { index: u16 },
    New { index: u16 },
    NewArray { atype: u8 },
    ArrayLength,
    IfNull { offset: i16 },
    IfNonNull { offset: i16 },
}

impl OpCode {
    pub fn from(bytes: &[u8], at_pc: usize) -> OpCode {
        use OpCode::*;
        return match bytes[at_pc] {
            0x0 => Nop,
            0x2 => IconstM1,
            0x3 => Iconst0,
            0x4 => Iconst1,
            0x5 => Iconst2,
            0x6 => Iconst3,
            0x7 => Iconst4,
            0x8 => Iconst5,
            0x9 => Lconst0, 
            0xa => Lconst1,
            0x10 => Bipush { byte: bytes[at_pc + 1] as i8 },
            0x11 => Sipush { value: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0x12 => Ldc { index: bytes[at_pc + 1] },
            0x14 => Ldc2w { index: u16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0x15 => Iload { index: bytes[at_pc + 1] },
            0x16 => Lload { index: bytes[at_pc + 1] },
            0x1a => Iload0,
            0x1b => Iload1,
            0x1c => Iload2,
            0x1d => Iload3,
            0x1e => Lload0,
            0x1f => Lload1,
            0x20 => Lload2,
            0x21 => Lload3,
            0x2a => Aload0,
            0x2b => Aload1,
            0x2c => Aload2,
            0x2d => Aload3,
            0x2e => Iaload,
            0x34 => Caload,
            0x36 => Istore { index: bytes[at_pc + 1] },
            0x37 => Lstore { index: bytes[at_pc + 1] }, 
            0x3b => Istore0,
            0x3c => Istore1,
            0x3d => Istore2,
            0x3e => Istore3,
            0x3f => Lstore0,
            0x40 => Lstore1,
            0x41 => Lstore2,
            0x42 => Lstore3,
            0x4b => Astore0,
            0x4c => Astore1,
            0x4d => Astore2,
            0x4e => Astore3,
            0x4f => Iastore,
            0x55 => Castore,
            0x57 => Pop,
            0x59 => Dup,
            0x60 => Iadd,
            0x61 => Ladd,
            0x64 => Isub,
            0x65 => Lsub,
            0x68 => Imul,
            0x69 => Lmul,
            0x6c => Idiv,
            0x6d => Ldiv,
            0x70 => Irem,
            0x74 => Ineg,
            0x78 => Ishl,
            0x79 => Lshl,
            0x7c => Iushr,
            0x7e => Iand,
            0x80 => Ior,
            0x85 => I2l,
            0x88 => L2i,
            0x91 => I2b,
            0x92 => I2c,
            0x94 => Lcmp,
            0x84 => Iinc { index: bytes[at_pc + 1], immediate: bytes[at_pc + 2] as i8 },
            0x99 => IfEq { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0x9a => IfNe { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0x9b => IfLt { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0x9c => IfGe { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0x9d => IfGt { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0x9e => IfLe { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0x9f => IfICmpEq { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xa0 => IfICmpNe { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xa1 => IfICmpLt { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xa2 => IfICmpGe { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xa3 => IfICmpGt { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xa4 => IfICmpLe { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xa7 => Goto { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xac => Ireturn,
            0xb0 => Areturn,
            0xb1 => Return,
            0xb2 => GetStatic { index: u16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xb3 => PutStatic { index: u16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xb4 => GetField { index: u16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xb5 => PutField { index: u16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xb6 => InvokeVirtual { index: u16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xb7 => InvokeSpecial { index: u16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xb8 => InvokeStatic { index: u16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xbb => New { index: u16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xbc => NewArray { atype: bytes[at_pc + 1] },
            0xbe => ArrayLength,
            0xc6 => IfNull { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            0xc7 => IfNonNull { offset: i16::from_be_bytes([ bytes[at_pc + 1], bytes[at_pc + 2] ]) },
            _ => unimplemented!("opcode 0x{:02x}", bytes[at_pc])
        };
    }
}
